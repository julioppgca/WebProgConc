<!DOCTYPE html>
<html>
<meta charset="UTF-8">
<link rel="stylesheet" type="text/css" href="styles/styles.css">

<title>Producer Consumer Animation - PPGCA</title>

<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<style>
canvas {
    border:10px solid #d3d3d3;
    background-color: #f1f1f1;
}
</style>
</head>


<body>

<table id="t01">
	<tr>
		<th> <button onclick="ChangeLangPor()">Português</button> </th>
		<th> <button onclick="ChangeLangEng()">English</button>  </th>
	</tr>
</table>

<H1 id="headerE"> Producer Consumer Problem</H1>
<H1 id="headerP" hidden=true> O Problema do Produtor e Consumidor</H1>
<div id=textE> 
In computing, the producer–consumer problem (also known as the bounded-buffer problem) 
is a classic example of a multi-process synchronization problem. The problem describes two processes, 
the producer and the consumer, who share a common, fixed-size buffer used as a queue. 
The producer's job is to generate data, put it into the buffer, and start again. At the same time, 
the consumer is consuming the data (i.e., removing it from the buffer), 
one piece at a time. The problem is to make sure that the producer won't try to add data into the buffer 
if it's full and that the consumer won't try to remove data from an empty buffer.

The solution for the producer is to either go to sleep or discard data if the buffer is full. 
The next time the consumer removes an item from the buffer, it notifies the producer, 
who starts to fill the buffer again. In the same way, the consumer can go to sleep if it 
finds the buffer to be empty. The next time the producer puts data into the buffer, 
it wakes up the sleeping consumer. The solution can be reached by means of inter-process communication, 
typically using semaphores. An inadequate solution could result in a deadlock where both processes 
are waiting to be awakened. The problem can also be generalized to have multiple producers and consumers.
</div> <br>
<div id="textP" hidden=true>
Em computação, o problema do produtor-consumidor (também conhecido como o problema limitado-tampão)
é um exemplo clássico de um problema de sincronização multi-processo. O problema descreve dois processos,
o produtor eo consumidor, que compartilham um buffer comum, de tamanho fixo usado como uma fila.
O trabalho do produtor é gerar dados, colocá-lo no buffer, e começar novamente. Ao mesmo tempo,
o consumidor está a consumir os dados (isto é, retirando-a do tampão),
uma peça de cada vez. O problema é ter certeza de que o produtor não vai tentar adicionar dados para o buffer
Se ele está cheio e que o consumidor não vai tentar remover dados de um buffer vazio.

A solução para o produtor, quer seja para ir dormir ou descartar dados se o buffer está cheio.
A próxima vez que o consumidor retira um item do buffer, ele notifica o produtor,
que começa a encher de novo o tampão. Da mesma forma, o consumidor pode ir dormir se
encontra o buffer estar vazio. A próxima vez que o produtor coloca os dados no buffer,
acorda o consumidor dormir. A solução pode ser alcançada por meio de comunicação entre processos,
tipicamente utilizando semáforos. Uma solução inadequada poderia resultar num bloqueio em que ambos os processos
estão à espera de ser despertado. O problema também pode ser generalizada para ter vários produtores e consumidores.
</div><br>

<table id="t01" >
  <tr>
    <th>Producer</th>
    <th>Buffer</th> 
    <th>Consumer</th>
  </tr>
	  
	<tr>
	<td>Speed
	<select id=ProdAnimSpeed > 
	  <option value="3000">Slow</option>
	  <option value="1000">Med.</option>
	  <option value="500">Fast</option>
	</select>
	</td>

<td>Size
	<select id=BufferSize > 
	  <option value="3">3 Pos.</option>
	  <option value="5">5 Pos.</option>
	  <option value="7">7 Pos.</option>
	</select>
</td>

<td>Speed
<select id=ConsAnimSpeed > 
  <option value="1">Slow</option>
  <option value="2">Med.</option>
  <option value="4">Fast</option>
</select>
</td>

</tr>

<tr>
<td>Produce
 <select id=Item2Produce > 
  <option value="10">10 Items</option>
  <option value="15">15 Items</option>
  <option value="25">25 Items</option>
</select>
</td>

<td> 
<button onclick="stopGame()">Reset</button>
<button onclick="startGame()">Go</button>
</td>

<td> 
</td>
</tr>

</table>

<canvas id="container"></canvas>

<script>

/*---------------------------------------------
 
 			Language Settings
 
 ---------------------------------------------*/
function ChangeLangPor(){
	document.getElementById("headerP").hidden=false;
	document.getElementById("textP").hidden=false;
	document.getElementById("textE").hidden=true;
	document.getElementById("headerE").hidden=true;
}
function ChangeLangEng(){
	document.getElementById("headerP").hidden=true;
	document.getElementById("textP").hidden=true;
	document.getElementById("textE").hidden=false;
	document.getElementById("headerE").hidden=false;
}

/*---------------------------------------------

		Constant Parameters Definition

---------------------------------------------*/
//Animate speed adjust
const AnimateSpeed = 20;

//limits
const maxX=800;
const maxY=400;
const bufferXsize=65;
const bufferYsize=400;
const bufferXpos=maxX/2-bufferXsize/2;
const bufferYpos=0;
const itemSize=50;

/*---------------------------------------------

			Global Variables

---------------------------------------------*/
var producer;
var consumer;
var buffer;
var bufferControl=0;
var prod=[];
var i = 0;
var j=0;
var dest;
/*---------------------------------------------

  				Init  Functions

---------------------------------------------*/
function startGame() {
  
    myGameArea.start();
    produceItem();
    //consumeItem();
    producer=new component(150, 300,  "#8ae234" , 0, 50, 0, "Producer");
    consumer=new component(150, 300, "#ef2929", 650, 50, 0, "Consumer");
    buffer=new component(bufferXsize, bufferYsize, "#729fcf",bufferXpos, bufferYpos, 0, "Buffer");
    
}
function stopGame(){
	myGameArea.stop();
	myGameArea.clear();	
	prod=[];
	i=0;
	bufferControl=0;
	//location.reload();
}

var myGameArea = {
	    //canvas : document.createElement("canvas"),
	    
	    canvas : document.getElementById("container"),
	    start : function() {
	        this.canvas.width = 800;
	        this.canvas.height = 400;
	        this.context = this.canvas.getContext("2d");
	        //document.body.insertBefore(this.canvas, document.body.childNodes[0]);
	        this.frameNo = 0;
	        this.interval = setInterval(updateGameArea, AnimateSpeed);
	 
	    },
	    stop : function() {
	        clearInterval(this.interval);
	    },    
	    clear : function() {
	        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
	    }
	}

function component(width, height, color, x, y, speed, type) {
    this.width = width;
    this.height = height;
    this.angle = 0;
    this.speed = speed;
    this.buffer = 0;
    this.lbuffer = 1;
    this.x = x;
    this.y = y;
    this.type=type;
   
    this.update = function(item){
        ctx = myGameArea.context;
        ctx.fillStyle = color;
        ctx.fillRect(this.x, this.y, this.width, this.height);
        
        ctx.font = "22px Arial";
        if(type) {
        	ctx.fillStyle = "white";
        	ctx.textAlign = "center";
        	if(type=="Buffer") 
        	{
        		if (item) ctx.fillText(type+" "+item,this.x+this.width/2,30);
        		else ctx.fillText(type,this.x+this.width/2,30);
        	}
        	else if(item) ctx.fillText(type+" "+item,this.x+this.width/2,this.y+this.height/2);
        	else ctx.fillText(type,this.x+this.width/2,this.y+this.height/2);
        }
    }
    this.newPos = function() {
        this.x += this.speed * Math.sin(this.angle);
        this.y -= this.speed * Math.cos(this.angle);
    }
    
    this.move = function(dest,speed){
    	if(dest=="move2buffer")
    	{
    	if(this.x<(bufferXpos+bufferXsize/2)-itemSize/2)	this.x +=speed;
    	else if (this.buffer==0){
    		//if(i>document.getElementById("BufferSize").value)
    		this.y = this.type*itemSize;
    		this.buffer=1;
    		//bufferControl++;
    		//consumeItem();//dest="move2consumer";
    		console.log("Buffer +:"+bufferControl);	
    		}
    	}
    	else if(dest=="move2consumer")
    	{
    		//console.log("consumer move");
    		if(this.x<750){
    			this.y = 150;
    			this.x +=speed;//this.speed;  
 				if(this.lbuffer==1){
 					this.lbuffer=0;
 					bufferControl--;
 				}
    		}
    		//if(this.lbuffer==1){this.lbuffer=0;bufferControl--; }
    		else if(this.angle == 0){
    			this.angle=1;
    			//bufferControl--;
    			this.y = this.type*itemSize;
    			console.log("Buffer -:"+bufferControl);
    			if(j<document.getElementById("Item2Produce").value)j++;
    			console.log("Item arrived: "+j);
    		}
    		    	
    	}
    }

}

function updateGameArea() {
    myGameArea.clear();
   	producer.update();
   	consumer.update();
   	buffer.update();
    
   	for(i=j;i<prod.length;i++)
   	{
   		prod[i].move(dest,2);
    	prod[i].update();
    }
   	if(i>1){
   	dest="move2consumer";
   	prod[j].move(dest,parseInt(document.getElementById("ConsAnimSpeed").value));//1);//document.getElementById("ConsAnimSpeed").value);
	prod[j].update();
	dest="move2buffer";}
   	//console.log(parseInt(document.getElementById("ConsAnimSpeed").value));
}

/*---------------------------------------------

	 Fancy thing  - get a random collor

---------------------------------------------*/

function getRandomColor() {
    var letters = '0123456789ABCDEF';
    var color = '#';
    for (var i = 0; i < 6; i++ ) {
        color += letters[Math.floor(Math.random() * 16)];
    }
    return color;
}


/*---------------------------------------------

				Produce Item

---------------------------------------------*/
function produceItem(){
	if(i++<=document.getElementById("Item2Produce").value) 
	{
		console.log("Max: " + document.getElementById("Item2Produce").value);
		var produceTimer = setInterval(function(){
		if((bufferControl<document.getElementById("BufferSize").value)&(i<document.getElementById("Item2Produce").value) )
			{
			prod.push(new component(itemSize, itemSize, getRandomColor(), 120, 150,1,(i+1)));
			dest="move2buffer";
			bufferControl++;
			//consumeItem();
			console.log("Produced..: "+i);
			}
		//else clearInterval(produceTimer);
		},document.getElementById("ProdAnimSpeed").value)
	}else clearInterval(produceTimer);	
}

/*---------------------------------------------

				Consume Item

---------------------------------------------*/
/*
function consumeItem(){
			setInterval(function(){console.log("Consumir");
				if(bufferControl>0) {
					dest="move2consumer";
					//console.log(dest);
					//prod[j].move(dest,0.5);
		   			//prod[j].update();
		    	}	
			},1000);//document.getElementById("ConsAnimSpeed").value)
}*/

/* var toggle=1;
setInterval(function(){
	 
	if(toggle){
		dest="move2buffer";//produceItem();
		toggle=0;
	}
	else{
		consumeItem();
		toggle=1;
	}
	
}, 1000) */


</script>

</body>
</html>
